message: |
 Testing topology for VXLAN to FRR hosts using iBGP over eBGP with SR Linux

 Use case with 3 customers and Internet access:
 1. Customer 1 can reach their own servers and the Internet
 2. Customer 2 can reach their own servers, Customer 3 and the Internet
 3. Customer 3 can reach their own servers and Customer 2, but not Internet

 Uses VRF route leaking on the FRR hosts, with a hub-spoke EVPN transit backbone to the spine(s) for Internet

 Control plane: EVPN with iBGP-over-eBGP
 P2P: BGP unnumbered with RFC8950 (ipv6 next hops for ipv4 prefixes)

 * vm1 and vm2 should be able to ping each other: docker exec -it clab-EVPN-VXLAN-to-hosts-vm1 ping 172.16.0.2 -c 2
 * vm1 can ping the Internet:                     docker exec -it clab-EVPN-VXLAN-to-hosts-vm1 ping 8.8.8.8 -c 2
 * vm3 can ping Customer 3 servers like vm5:      docker exec -it clab-EVPN-VXLAN-to-hosts-vm3 ping 172.16.2.5 -c 2
 * ... and on SR Linux leaves bm1:                docker exec -it clab-EVPN-VXLAN-to-hosts-vm3 ping 172.16.2.6 -c 2

 Note that pinging a host that has been silent may not work immediately. c3-vlan would normally have an anycast gateway address 
 (because it is distributed over multiple nodes) and hence ARP for bm1 would work. As it is, this is not the case

addressing:
  fabric:
    # unnumbered: true # old style based on loopback IPs
    ipv4: true
    ipv6: true

bgp:
  advertise_loopback: all
  as: 65000 # iBGP AS
  as_list:
    65000: # EVPN overlay with Route Reflector at spine(s)
      members: [ leaf1,leaf2,spine,frr-bgp-s1,frr-bgp-s2 ]
      rr: [ spine ]
  
  # sessions: # Transport sessions to use, use defaults
  #  ipv4: [ ibgp, ebgp ] # IBGP-v4 over EBGP-v6
  #  ipv6: [ ebgp ]
  activate: # Address families to activate
    ipv4: [ ebgp ] # Only activate ipv4 over eBGP, use iBGP for EVPN only

evpn.session: [ ibgp ] # default

provider: clab

# vrf.bgp: False # Prevent ebgp session between leaves

vrfs:
  # Hub/spoke vrfs: evpn.transit_vni set to the same value on both spine and FRR nodes
  #
  internet:
    evpn.transit_vni: True
    loopback: True

  customer1:
    evpn.transit_vni: True
    import: [customer1,internet]
    export: [customer1]
  
  customer2:
    evpn.transit_vni: True
    import: [customer2,internet,customer3]
    export: [customer2]

  customer3: # Plain vlan between bare metal servers, but allow connecting to customer2
    evpn.transit_vni: True
    import: [customer3,customer2]
    export: [customer3]

vlans:
  c1-vlan:
    vni: True
    vrf: customer1

  c2-vlan:
    vni: True
    vrf: customer2

  c3-vlan:
    vni: True
    vrf: customer3

  internet:
    vni: True
    mode: route   # No irb interface -> no l2 vni possible
    vrf: internet

# vxlan.vlans: [ *all the above* ]

groups:
  frr_servers: # TODO: VRF route leaking using route maps on these hosts
    members: [ frr-bgp-s1, frr-bgp-s2 ]
    device: frr
    module: [ vlan,vxlan,bgp,evpn,vrf ]
    config: [ frr-allowas-in.j2,frr-no-readvertise.j2 ]

  hosts:
    members: [ vm1,vm2,vm3,vm4,bm1,bm2,vm5 ]
    device: linux
    module: []

  fabric:
    members: [ spine, leaf1, leaf2 ]
    device: srlinux
    module: [ vlan,vxlan,bgp,evpn,vrf ]

nodes:
  # Customer 1&2 Virtual Machines
  vm1:
  vm2:
  vm3:
  vm4:

  # Customer 3 bare metal servers, TODO LAG with EVPN-MH
  vm5:
  bm1:
  bm2:

  spine:
    bgp.local_as: 65100
    clab:
      type: ixrd3 # 32x100G ports

    vrfs:
      internet: # Pull in internet vrf for route leaking, define import/export here as hub site
         
       import: [ "64999:0" ]
       export: [ internet ]

  leaf1:
    bgp.local_as: 65101
  leaf2:
    bgp.local_as: 65102

  frr-bgp-s1:
    bgp.local_as: 65103 # Cannot be same as overlay, else AS loop

    vrfs:
      internet: # Internet vrf for route leaking, define import/export here for spoke sites
         
       import: [internet,customer1,customer2]  # import connected routes to advertise to spine
       export: [ "64999:0", internet ]         # Unique backbone community used as EVPN RT, 'internet' for vrf leaking

      customer3: # Need to pull in this VRF too, for leaking with customer2
       af:
        ipv4: True # Enable advertisement of ipv4 prefixes, should happen due to leaf1/leaf2 but doesn't

  frr-bgp-s2:
    bgp.local_as: 65103 # Same for all hosts -> hosts do not accept specific routes to other hosts unless allow-ownas is set

    # Copy & paste, cannot currently define this at group level
    vrfs:
      internet: # Internet vrf for route leaking, define import/export here for spoke sites
         
       import: [internet,customer1,customer2]  # import connected routes to advertise to spine
       export: [ "64999:0", internet ]         # Unique backbone community used as EVPN RT, 'internet' for vrf leaking

      customer3: # Need to pull in this VRF too, for leaking with customer2
       af:
        ipv4: True # Enable advertisement of ipv4 prefixes, should happen due to leaf1/leaf2 but doesn't

links:
- vm1:
  frr-bgp-s1:
    vlan.access: c1-vlan

- vm2:
  frr-bgp-s2:
    vlan.access: c1-vlan

- vm3:
  frr-bgp-s1:
    vlan.access: c2-vlan

- vm4:
  frr-bgp-s2:
    vlan.access: c2-vlan

- vm5:
  frr-bgp-s2:
    vlan.access: c3-vlan # Test: pull in vlan

- bm1:
  leaf1:
    vlan.access: c3-vlan

- bm2:
  leaf2:
    vlan.access: c3-vlan

# ECMP across both leaves
- frr-bgp-s1:
  leaf1:
  role: fabric

- frr-bgp-s1:
  leaf2:
  role: fabric

- frr-bgp-s2:
  leaf1:
  role: fabric

- frr-bgp-s2:
  leaf2:
  role: fabric

- spine:
   ipv4: 8.8.8.8/32 # Cannot do /32 on irb interface
  type: stub
  vlan.access: internet

- spine:
  leaf1:
   ifindex: 49
  role: fabric
- spine:
  leaf2:
   ifindex: 49
  role: fabric
